这里总结数组中常见的一种题型。

In-place 前后交换型。



**MOVE ZEROS**

Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Note** that you must do this in-place without making a copy of the array.

 

**Example 1:**

```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```

**Example 2:**

```
Input: nums = [0]
Output: [0]
```



**Sort Array By Parity**

Solution

Given an array `A` of non-negative integers, return an array consisting of all the even elements of `A`, *followed by* all the odd elements of `A`.

You may return any answer array that satisfies this condition.

 

**Example 1:**

```
Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
```



上面是两个题

一个是将0移动到数组最后

第二个是偶数放前面，奇数放后面。

其实之前那个爬山问题也是，但那个问题不存在交换问题，但是也可以从两边开始思考。


​        以第二题为例，讲解

```java
 public int[] sortArrayByParity(int[] A) {
        int length = A.length;
        int temp;
 		for (int i = 0, j = 0; i <length; i++) 
    {
        if (A[i]%2 == 0 && A[j]%2 != 0) //如果满足了后面的A[i]是偶数，前面的A[j]是奇数，那么交换位置
        { 
            temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
        while (j < i && A[j]%2 == 0) //在大循环里没有对j有操作，放在这里是为了找到数组前面的奇数，到时候只要满足A[i]是偶数就可以交换了
        {
            j++;
        } 
    }
    return A;   
       
}
```
