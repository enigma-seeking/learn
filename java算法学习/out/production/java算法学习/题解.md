3.28今天学习数组碰到了问题，就是考虑这种题的思路之前没有，希望可以通过这个题有所长进。

这个题是Easy题，但也不要气馁，虽然在计院大一水平，但是只要每天去学习记笔记，我相信我很快就能赶上来。



Given an array of integers `arr`, return *`true` if and only if it is a valid mountain array*.

Recall that arr is a mountain array if and only if:

- `arr.length >= 3`

- There exists some

   

  ```
  i with 0 < i < arr.length - 1
  ```

  such that:

  - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
  - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

<img src="D:\research_workshop_new\算法\learn\java算法学习\题解.assets\hint_valid_mountain_array.png" alt="img" style="zoom:50%;" />

 

**Example 1:**

```
Input: arr = [2,1]
Output: false
```

**Example 2:**

```
Input: arr = [3,5,5]
Output: false
```

**Example 3:**

```
Input: arr = [0,3,2,1]
Output: true
```



这个题我出现的问题是不能找到一个很好的角度，将可行不可行标准简单的列出来，需要很多if。

题解给了一种思路，下面的discuss也有两个好的角度。

题解思路是，这题是山，那么我就爬山，有点用物理意义解题的感觉。

**Intuition**

If we walk along the mountain from left to right, we have to move strictly up, then strictly down.

**Algorithm**

Let's walk up from left to right until we can't: that has to be the peak. We should ensure the peak is not the first or last element. Then, we walk down. If we reach the end, the array is valid, otherwise its not.

```java
class Solution {
    public boolean validMountainArray(int[] A) {
        int N = A.length;
        int i = 0;

        // walk up
        while (i+1 < N && A[i] < A[i+1])
            i++;

        // peak can't be first or last
        if (i == 0 || i == N-1)
            return false;

        // walk down
        while (i+1 < N && A[i] > A[i+1])
            i++;

        return i == N-1;
    }
}
```

这个就是先爬山到达山顶，在下山结束，在这过成功验证是没有平路没有波动且山顶不在边缘。



discuss解法

```python
"""
    1st approach: 2 pointers

    e.g. 1
    3, 4, 6, 5, 4
          ^
        left
        right
    left == right so a valid mountain

    e.g. 2
    3, 5, 6, 1, 2, 7, 4, 2, 1
          ^        ^
        left    right

    left != right so not a valid mountain

    e.g. 3
    3, 4, 5, 5, 5
          ^     ^
        left    right
    left != right so not a valid mountain

    e.g. 4
    3, 4, 5, 6, 7
                ^
                left
                right
    left == right but they are out of bound so not a valid mountain

    Time    O(n)
    Space   O(1)
    180 ms, faster than 75.98%
"""


class Solution(object):
    def validMountainArray(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """
        if len(A) < 3:
            return False
        left = 0
        for i in range(len(A)-1):
            if A[i+1] <= A[i]:
                left = i
                break
        right = 0
        for i in range(len(A)-1, 0, -1):
            if A[i-1] <= A[i]:
                right = i
                break
        if left == right and left > 0 and right+1 < len(A):
            return True
        return False
```



这个解法和上面有所不同，上面是一个人从一侧上山，完成上山加下山过程。

而这个解法是两个人从两侧同时上山，每人只用完成上山过程就可以。

这里，每人要可以成功上山，并且可以会面才算是true；如果有一人不能成功上山或者上山后两人不能见面，则为false(山顶在一侧边缘也算。)

