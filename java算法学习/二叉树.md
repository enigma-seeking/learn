### Pre-order Traversal

Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree. Here is an example:

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401213614917.png" alt="image-20210401213614917" style="zoom:50%;" />

java代码实现

```java
/**

 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
   */
   class Solution {
   public List<Integer> preorderTraversal(TreeNode root) {
       //我这种方法节点不能往上返回
   //         List<Integer> ans = new ArrayList<>();
   //         TreeNode curr = root;
   //         while(curr.left != null || curr.right != null)
   //         {
   //             ans.add(curr.val);
   //             if(curr.left != null)
   //             {
   //                 TreeNode lastroot = curr;
   //                 curr = curr.left;
   //             }
   //             else
   //             {
   //                 curr = curr.right;
   //             }
           

//         }
//         ans.add(curr.val);
//         return ans;
        

        //针对我上面的问题题解通过栈正好可以解决，可以学习一下其中的思想：想要往上返回就可以用栈结构。
        List<Integer> list = new LinkedList<Integer>();
        //List<?>初始化方法要学习，添加的话用add方法。
        Stack<TreeNode> rights = new Stack<TreeNode>();
        while(root != null) {
            list.add(root.val);
            if (root.right != null) {
                rights.push(root.right);
            }
            root = root.left;
            if (root == null && !rights.isEmpty()) {
                root = rights.pop();
            }
        }
        return list;
    }

}
```

大部分不明白的内容都在这上有所标注，一个是List<?>初始化方法不知道怎么写，二是不知道通过栈去完成导致无法返回上层。但是在这里都是迭代的方法没有用递归的方法。

### In-order Traversal

------

In-order traversal is to traverse the left subtree first. Then visit the root. Finally, traverse the right subtree.

Let's do in-order traversal together:



<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401213929714.png" alt="image-20210401213929714" style="zoom:50%;" />



Typically, for `binary search tree`, we can retrieve all the data in sorted order using in-order traversal.

通常，对于二叉搜索树，我们可以使用有序遍历以排序的顺序检索所有数据。 

***这个遍历最开始我没看懂，这里进行说明，之后再看可以有所参考，首先左树（B为根的这个），再看左树也就是A，遍历完左树（A）到根节点B，然后遍历右树（D为根），再看左树（C）然后是根节点（D）再遍历右树（E)，结束后返回根节点F。所以就是A-B-C-D-E-F。右树G为根节点，因为没有左树，所以直接是G，然后遍历右树。所以是F-G-H-I***

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<Integer>();
        //List<?>初始化方法要学习，添加的话用add方法。
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;

        while(cur!=null || !stack.empty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }

        
        return list;
    }
}
```



### Post-order Traversal

------

Post-order traversal is to traverse the left subtree first. Then traverse the right subtree. Finally, visit the root.

Here is an animation to help you understand post-order traversal:

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401214131533.png" alt="image-20210401214131533" style="zoom:50%;" />

It is worth noting that when you delete nodes in a tree, deletion process will be in post-order. That is to say, when you delete a node, you will delete its left child and its right child before you delete the node itself.

了解了中序遍历这个后序遍历也就能理解。

A-C-E-D-B-H-I-G-F

删除过程类似后序遍历。

***Recursive***递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        if (root == null) return ans;

        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            ans.addFirst(cur.val);
            if (cur.left != null) {
                stack.push(cur.left);
            }
            if (cur.right != null) {
                stack.push(cur.right);
            } 
        }
        return ans;
    }
}
```

