### Pre-order Traversal

Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree. Here is an example:

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401213614917.png" alt="image-20210401213614917" style="zoom:50%;" />

java代码实现

```java
/**

 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
   */
   class Solution {
   public List<Integer> preorderTraversal(TreeNode root) {
       //我这种方法节点不能往上返回
   //         List<Integer> ans = new ArrayList<>();
   //         TreeNode curr = root;
   //         while(curr.left != null || curr.right != null)
   //         {
   //             ans.add(curr.val);
   //             if(curr.left != null)
   //             {
   //                 TreeNode lastroot = curr;
   //                 curr = curr.left;
   //             }
   //             else
   //             {
   //                 curr = curr.right;
   //             }
           

//         }
//         ans.add(curr.val);
//         return ans;
        

        //针对我上面的问题题解通过栈正好可以解决，可以学习一下其中的思想：想要往上返回就可以用栈结构。
        List<Integer> list = new LinkedList<Integer>();
        //List<?>初始化方法要学习，添加的话用add方法。
        Stack<TreeNode> rights = new Stack<TreeNode>();
        while(root != null) {
            list.add(root.val);
            if (root.right != null) {
                rights.push(root.right);
            }
            root = root.left;
            if (root == null && !rights.isEmpty()) {//到达树的最底部了
                root = rights.pop();
            }
        }
        return list;
    }

}

// recursively
public List<Integer> preorderTraversal1(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    dfs(root, ret);
    return ret;
}

private void dfs(TreeNode root, List<Integer> ret) {
    if (root != null) {
        ret.add(root.val);
        dfs(root.left, ret);
        dfs(root.right, ret);
    }
}

// iteratively
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            ret.add(node.val);
            stack.push(node.right);
            stack.push(node.left);
        }
    }//我个人更喜欢这种算法但是还没有分析那种方法最高效。
    return ret;
}
```

大部分不明白的内容都在这上有所标注，一个是List<?>初始化方法不知道怎么写，二是不知道通过栈去完成导致无法返回上层。但是在这里都是迭代的方法没有用递归的方法。

### In-order Traversal

------

In-order traversal is to traverse the left subtree first. Then visit the root. Finally, traverse the right subtree.

Let's do in-order traversal together:



<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401213929714.png" alt="image-20210401213929714" style="zoom:50%;" />



Typically, for `binary search tree`, we can retrieve all the data in sorted order using in-order traversal.

通常，对于二叉搜索树，我们可以使用有序遍历以排序的顺序检索所有数据。 

***这个遍历最开始我没看懂，这里进行说明，之后再看可以有所参考，首先左树（B为根的这个），再看左树也就是A，遍历完左树（A）到根节点B，然后遍历右树（D为根），再看左树（C）然后是根节点（D）再遍历右树（E)，结束后返回根节点F。所以就是A-B-C-D-E-F。右树G为根节点，因为没有左树，所以直接是G，然后遍历右树。所以是F-G-H-I***

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<Integer>();
        //List<?>初始化方法要学习，添加的话用add方法。
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;

        while(cur!=null || !stack.empty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }

        
        return list;
    }
}

// recursively
public List<Integer> inorderTraversal1(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    dfs(root, ret);
    return ret;
}

private void dfs(TreeNode node, List<Integer> ret) {
    if (node != null) {
        dfs(node.left, ret);
        ret.add(node.val);
        dfs(node.right, ret);
    }
}


```



### Post-order Traversal

------

Post-order traversal is to traverse the left subtree first. Then traverse the right subtree. Finally, visit the root.

Here is an animation to help you understand post-order traversal:

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\image-20210401214131533.png" alt="image-20210401214131533" style="zoom:50%;" />

It is worth noting that when you delete nodes in a tree, deletion process will be in post-order. That is to say, when you delete a node, you will delete its left child and its right child before you delete the node itself.

了解了中序遍历这个后序遍历也就能理解。

A-C-E-D-B-H-I-G-F

删除过程类似后序遍历。

***Recursive***递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        if (root == null) return ans;

        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            ans.addFirst(cur.val);
            if (cur.left != null) {
                stack.push(cur.left);
            }
            if (cur.right != null) {
                stack.push(cur.right);
            } 
        }
        return ans;
    }
}


// recursively
public List<Integer> postorderTraversal1(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    dfs(root, ret);
    return ret;
}

private void dfs(TreeNode root, List<Integer> ret) {
    if (root != null) {
        dfs(root.left, ret);
        dfs(root.right, ret);
        ret.add(root.val);
    }
}


```



# 二叉树级序遍历

Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).

 

**Example 1:**

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\tree1.jpg" alt="img" style="zoom:50%;" />

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    List<List<Integer>> wrapList = new LinkedList<List<Integer>>();
    if(root == null) return wrapList;
    
    queue.offer(root);
    while(!queue.isEmpty()){
        int levelNum = queue.size();
        List<Integer> subList = new LinkedList<Integer>();
        for(int i=0; i<levelNum; i++) {
            if(queue.peek().left != null) queue.offer(queue.peek().left);
            if(queue.peek().right != null) queue.offer(queue.peek().right);
            subList.add(queue.poll().val);
        }
        wrapList.add(subList);
    }
    return wrapList;
}
```


Maximum Depth of Binary Tree

Solution

Given the `root` of a binary tree, return *its maximum depth*.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

 

**Example 1:**

![img](D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\tmp-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2
```

**Example 3:**

```
Input: root = []
Output: 0
```

**Example 4:**

```
Input: root = [0]
Output: 1
```

```java
class Solution {
    public int maxDepth(TreeNode root) {
        // if(root==null){
        //     return 0;
        // }
        // return 1+Math.max(maxDepth(root.left),maxDepth(root.right));

        
//         if(root == null) {
//         return 0;
//         }

//         Stack<TreeNode> stack = new Stack<>();
//         Stack<Integer> value = new Stack<>();
//         stack.push(root);
//         value.push(1);
//         int max = 0;
//         while(!stack.isEmpty()) {
//             TreeNode node = stack.pop();
//             int temp = value.pop();
//             max = Math.max(temp, max);
//             if(node.left != null) {
//                 stack.push(node.left);
//                 value.push(temp+1);
//             }
//             if(node.right != null) {
//                 stack.push(node.right);
//                 value.push(temp+1);
//             }
//         }
//         return max;

    if(root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int count = 0;
    while(!queue.isEmpty()) {
        int size = queue.size();
        while(size-- > 0) {
            TreeNode node = queue.poll();
            if(node.left != null) {
                queue.offer(node.left);
            }
            if(node.right != null) {
                queue.offer(node.right);
            }
        }
        count++;
    }
    return count;
    }
    }
```







Path Sum

Solution

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

 

**Example 1:**

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\pathsum1.jpg" alt="img" style="zoom: 50%;" />

```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

**Example 2:**

<img src="D:\research_workshop_new\算法\learn\java算法学习\二叉树.assets\pathsum2.jpg" alt="img" style="zoom:50%;" />

```
Input: root = [1,2,3], targetSum = 5
Output: false
```

**Example 3:**

```
Input: root = [1,2], targetSum = 0
Output: false
```





```java
迭代
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        Stack<Integer> sums = new Stack<Integer>();

        stack.push(root);
        sums.push(targetSum);
        while(!stack.isEmpty()&&(root!=null)){
            int value = sums.pop();
            TreeNode top = stack.pop();
            
            if(top.left==null&&top.right==null&&top.val==value){
                return true;
            }
            if(top.right!=null){
                stack.push(top.right);
                sums.push(value-top.val);
            }
            if(top.left!=null){
                stack.push(top.left);
                sums.push(value-top.val);
            }

        }
        return false;
    }
}


递归
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;

        if(root.left == null && root.right == null) return sum == root.val;

        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

