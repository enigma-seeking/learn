大O表示法指出了算法运行时间的增速，说的是最糟糕的情景

从快到慢的顺序列出了你经常会遇到的5种大O运行时间

O(log n)

O(n)

O(n*log n)

O(n^2^)

O(n!)



数组与链表的对比。

本质区别：数组存储大小固定，位置紧靠；链表存储大小可调，位置随机，下一个位置存储在上一个元素中。

而这样的区别意味着链表在读取所有元素时效率很高，同时插入元素很方表；数组在随机访问时效率很高。

<img src="D:\research_workshop_new\算法\learn\算法.assets\image-20210310213443678.png" alt="image-20210310213443678" style="zoom: 33%;" />



递归

递归只是让解决方案更清晰，并没有性能上的优势，实际上，使用循环的性能更好。

使用递归时必须要告诉程序什么时候结束。这个停止递归的条件称为基线条件。



栈和调用栈

栈有压入和弹出，而我们调用函数相当于我们压入一个函数，而弹出时后压入的先弹出，栈帮助你跟踪函数，但是同时使用的内存也比较大了。

分而治之(divide and conquer)是一种解决递归问题的思想方法。

工作原理就是1.找出简单的基线条件    2.确定如何缩小问题的规模，使其符合基线条件。

